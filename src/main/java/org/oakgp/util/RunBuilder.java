/*
 * Copyright 2015 S. Webber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.oakgp.util;

import static java.util.Objects.requireNonNull;
import static org.oakgp.NodeSimplifier.simplify;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import java.util.logging.Logger;

import org.oakgp.evolve.GenerationEvolver;
import org.oakgp.evolve.GenerationEvolverImpl;
import org.oakgp.evolve.GeneticOperator;
import org.oakgp.evolve.crossover.AdfCrossoverWrapper;
import org.oakgp.evolve.crossover.AdfMutateWrapper;
import org.oakgp.evolve.crossover.CrossoverWrapper;
import org.oakgp.evolve.crossover.SubtreeCrossover;
import org.oakgp.evolve.mutate.MutateWrapper;
import org.oakgp.evolve.mutate.PointMutation;
import org.oakgp.evolve.mutate.SubTreeMutation;
import org.oakgp.function.Function;
import org.oakgp.function.Signature;
import org.oakgp.generate.AdfTreeGenerator;
import org.oakgp.generate.TreeGenerator;
import org.oakgp.generate.TreeGeneratorImpl;
import org.oakgp.node.AutomaticallyDefinedFunction;
import org.oakgp.node.ConstantNode;
import org.oakgp.node.Node;
import org.oakgp.primitive.ConstantSet;
import org.oakgp.primitive.FunctionSet;
import org.oakgp.primitive.PrimitiveSet;
import org.oakgp.primitive.PrimitiveSetImpl;
import org.oakgp.primitive.VariableSet;
import org.oakgp.rank.GenerationRanker;
import org.oakgp.rank.RankedCandidate;
import org.oakgp.rank.RankedCandidates;
import org.oakgp.rank.fitness.FitnessFunction;
import org.oakgp.rank.fitness.FitnessFunctionCache;
import org.oakgp.rank.fitness.FitnessFunctionGenerationRanker;
import org.oakgp.rank.tournament.RoundRobinTournament;
import org.oakgp.rank.tournament.TwoPlayerGame;
import org.oakgp.rank.tournament.TwoPlayerGameCache;
import org.oakgp.select.NodeSelectorFactory;
import org.oakgp.select.RankSelectionFactory;
import org.oakgp.terminate.CompositeTerminator;
import org.oakgp.terminate.MaxGenerationsTerminator;
import org.oakgp.terminate.MaxGenerationsWithoutImprovementTerminator;
import org.oakgp.terminate.TargetFitnessTerminator;
import org.oakgp.type.CommonTypes;
import org.oakgp.type.Types.Type;

/**
 * Provides a convenient way to configure and start a genetic programming run.
 *
 * @see <a href="http://oakgp.org/getting-started-with-oakgp">Getting Started with OakGP</a>
 */
public final class RunBuilder { // TODO remove any unused methods, add new cache()/noCache() and parallel()/sequential() methods
   private static final Random RANDOM = new JavaUtilRandomAdapter();
   private static final double RATIO_VARIABLES = .6;
   private static final int DEFAULT_CACHE_SIZE = 10000;

   private Type _returnType;
   private Random _random = RANDOM;
   private PrimitiveSet _primitiveSet;
   private GenerationRanker _generationRanker;
   private GenerationEvolver _generationEvolver;
   private Collection<Node> _initialPopulation;
   private boolean _parallel = true; // TODO change to Boolean and force to be explicitly specified
   private List<Signature> _automaticallyDefinedFunctions = new ArrayList<>();
   private TreeGenerator _treeGenerator;

   /**
    * Sets the required {@code Type} associated with the values produced as a result of evaluating the programs that are automatically generated by the run.
    */
   public RandomSetter setReturnType(final Type returnType) {
      _returnType = requireNonNull(returnType);
      _automaticallyDefinedFunctions.add(Signature.createSignature(returnType, CommonTypes.voidType())); // TODO avoid needing to include argument
      return new RandomSetter();
   }

   /**
    * Provides the option to set a random number generator, or to skip that option and instead configure the primitive set.
    * <p>
    * If you do not explicitly specify a random number generator then the {@code RunBuilder} will default to using {@link JavaUtilRandomAdapter}. Unless you
    * have a specific requirement about how random numbers are generated then the default random number generator will be sufficient.
    */
   public final class RandomSetter extends PrimitiveSetSetter {
      private RandomSetter() {
      }

      /** Sets the {@code Random} to use to generate random numbers required by the run. */
      public PrimitiveSetSetter setRandom(final Random random) {
         _random = requireNonNull(random);
         return new PrimitiveSetSetter();
      }
   }

   /** Allows the primitive set to be configured. */
   public class PrimitiveSetSetter {
      private PrimitiveSetSetter() {
      }

      /**
       * Sets the functions and terminal nodes that are available for use in the construction of programs generated by the run.
       */
      public GenerationRankerSetter setPrimitiveSet(final PrimitiveSet primitiveSet) {
         _primitiveSet = requireNonNull(primitiveSet);
         return new SequentialSetter();
      }

      public VariablesSetter setConstantSet(final ConstantSet constantSet) {
         return new VariablesSetter(constantSet);
      }

      /** Sets the constants that are available for use in the construction of programs generated by the run. */
      public VariablesSetter setConstants(final ConstantNode... constants) {
         return setConstantSet(new ConstantSet(constants));
      }
   }

   /** Allows the variable types to be configured. */
   public final class VariablesSetter {
      private final ConstantSet constantSet;

      private VariablesSetter(final ConstantSet constantSet) {
         this.constantSet = constantSet;
      }

      public VariablesRatioSetter setVariableSet(final VariableSet variableSet) {
         return new VariablesRatioSetter(constantSet, variableSet);
      }

      /**
       * Sets the {@code Type}s to associate with the variables available for use in the construction of programs generated by the run.
       */
      public VariablesRatioSetter setVariables(final Type... variableTypes) {
         return setVariableSet(VariableSet.createVariableSet(variableTypes));
      }
   }

   /** Allows the ratio of variables to constants to be configured. */
   public final class VariablesRatioSetter implements FunctionSetSetter {
      private final ConstantSet constantSet;
      private final VariableSet variableSet;

      private VariablesRatioSetter(ConstantSet constantSet, VariableSet variableSet) {
         this.constantSet = constantSet;
         this.variableSet = variableSet;
      }

      /**
       * Sets the ratio of terminal nodes that should be variable nodes, rather than constant nodes.
       *
       * @param ratioVariables
       *           a value in the range 0 to 1 (inclusive) which specifies the proportion of terminal nodes that should represent variables, rather than
       *           constants
       * @throws IllegalArgumentException
       *            if {@code ratioVariables} is not in the range 0 to 1 inclusive
       */
      public FunctionSetSetter setRatioVariables(final double ratioVariables) {
         if (ratioVariables < 0 || ratioVariables > 1) {
            throw new IllegalArgumentException("Ratio of variables must be in range 0 to 1, not: " + ratioVariables);
         }
         return new FunctionSetSetterImpl(constantSet, variableSet, ratioVariables);
      }

      @Override
      public SequentialSetter setFunctionSet(FunctionSet functionSet) {
         return setRatioVariables(RATIO_VARIABLES).setFunctionSet(functionSet);
      }
   }

   private final class FunctionSetSetterImpl implements FunctionSetSetter {
      private final ConstantSet constantSet;
      private final VariableSet variableSet;
      private final double ratioVariables;

      private FunctionSetSetterImpl(ConstantSet constantSet, VariableSet variableSet, double ratioVariables) {
         this.constantSet = constantSet;
         this.variableSet = variableSet;
         this.ratioVariables = ratioVariables;
      }

      @Override
      public SequentialSetter setFunctionSet(final FunctionSet functionSet) {
         _primitiveSet = new PrimitiveSetImpl(functionSet, constantSet, variableSet, _random, ratioVariables);
         return new SequentialSetter();
      }
   }

   public final class SequentialSetter extends GenerationRankerSetter {
      private SequentialSetter() {
      }

      public GenerationRankerSetter parallel() { // TODO have sequential() and set after fitnessfunction is set
         _parallel = true;
         return new GenerationRankerSetter();
      }
   }

   /** Allows the configuration of the mechanism for ranking candidates. */
   public class GenerationRankerSetter {
      private GenerationRankerSetter() {
      }

      /** Set the {@code GenerationRanker} used to rank and sort the candidates of a generation. */
      public InitialPopulationSetter setGenerationRanker(final GenerationRanker generationRanker) {
         _generationRanker = requireNonNull(generationRanker);
         return new InitialPopulationSetter();
      }

      /** Set the {@code FitnessFunction} used to determine the fitness of a candidate. */
      public InitialPopulationSetter setFitnessFunction(final FitnessFunction fitnessFunction) {
         requireNonNull(fitnessFunction);
         return setGenerationRanker(new FitnessFunctionGenerationRanker(ensureCached(fitnessFunction), _parallel));
      }

      private FitnessFunction ensureCached(final FitnessFunction fitnessFunction) {
         // TODO add cache()/noCache() option so not automatically applied
         if (fitnessFunction instanceof FitnessFunctionCache) {
            return fitnessFunction;
         } else {
            return new FitnessFunctionCache(DEFAULT_CACHE_SIZE, fitnessFunction);
         }
      }

      /** Set the {@code TwoPlayerGame} used to determine the relative fitness of two candidates. */
      public InitialPopulationSetter setTwoPlayerGame(final TwoPlayerGame twoPlayerGame) {
         requireNonNull(twoPlayerGame);
         return setGenerationRanker(new RoundRobinTournament(ensureCached(twoPlayerGame), _parallel));
      }

      private TwoPlayerGame ensureCached(final TwoPlayerGame twoPlayerGame) {
         if (twoPlayerGame instanceof TwoPlayerGameCache) {
            return twoPlayerGame;
         } else {
            return new TwoPlayerGameCache(DEFAULT_CACHE_SIZE, twoPlayerGame);
         }
      }
   }

   /** Allows the initial population to be specified. */
   public final class InitialPopulationSetter {
      private InitialPopulationSetter() {
      }

      /** Set the contents of the initial population. */
      public GenerationEvolverSetter setInitialPopulation(final java.util.function.Function<Config, Collection<Node>> initialPopulation) {
         return setInitialPopulation(initialPopulation.apply(new Config()));
      }

      /** Set the contents of the initial population. */
      private GenerationEvolverSetter setInitialPopulation(Collection<Node> initialPopulation) {
         _initialPopulation = requireNonNull(initialPopulation);
         return new GenerationEvolverSetter();
      }

      /** Set the number of randomly generated trees to include in the initial population. */
      public TreeDepthSetter setInitialPopulationSize(final int generationSize) {
         return new TreeDepthSetter(generationSize);
      }
   }

   /** Allows configuration of the maximum tree depth of trees randomly generated for the initial population. */
   public final class TreeDepthSetter {
      private final int generationSize;

      private TreeDepthSetter(final int generationSize) {
         this.generationSize = requiresPositive(generationSize);
      }

      // TODO remove
      public TreeDepthSetter automaticallyDefinedFunction(Signature signature) {
         _automaticallyDefinedFunctions.add(signature);
         return this;
      }

      /** Set the maximum depth of the trees randomly generated for the initial population. */
      public GenerationEvolverSetter setTreeDepth(final int treeDepth) { // TODO if adf create many trees
         requiresPositive(treeDepth);

         TreeGenerator treeGenerator;
         int adfCount = _automaticallyDefinedFunctions.size();
         if (adfCount == 1) {
            // NOTE using a NodeSet rather than an ArrayList - means the resulting population may be < generationSize (due to duplicates)
            // NOTE could instead do: Collection<Node> initialPopulation = new ArrayList<>();
            // NOTE could generate using a 50:50 split of TreeGeneratorImpl.grow and TreeGeneratorImpl.full
            // TODO check for infinite loop
            treeGenerator = TreeGeneratorImpl.grow(_primitiveSet, _random);
         } else {
            AutomaticallyDefinedFunction[] adfs = new AutomaticallyDefinedFunction[adfCount];
            for (int i = 1; i < adfCount; i++) {
               adfs[i] = new AutomaticallyDefinedFunction(i, _automaticallyDefinedFunctions.get(i));
            }

            PrimitiveSet[] primitiveSets = new PrimitiveSet[adfCount];
            for (int i = 0; i < adfCount; i++) {
               PrimitiveSetImpl primitiveSet = (PrimitiveSetImpl) _primitiveSet;

               for (int f = i + 1; f < adfCount; f++) {
                  primitiveSet = primitiveSet.addFunction(adfs[f]);
               }
               for (int v = 0; v < _automaticallyDefinedFunctions.get(i).getArgumentTypesLength(); v++) {
                  primitiveSet = primitiveSet.addVariable("adf" + i + "v" + v, _automaticallyDefinedFunctions.get(i).getArgumentType(v));
               }

               primitiveSets[i] = primitiveSet;
            }

            TreeGenerator[] treeGenerators = new TreeGenerator[adfCount];
            Type[] returnTypes = new Type[adfCount];
            for (int i = 0; i < treeGenerators.length; i++) {
               treeGenerators[i] = TreeGeneratorImpl.grow(primitiveSets[i], _random);
               returnTypes[i] = _automaticallyDefinedFunctions.get(i).getReturnType();
            }
            treeGenerator = new AdfTreeGenerator(treeGenerators, returnTypes);
            _primitiveSets = primitiveSets;
            _treeGenerators = treeGenerators;
         }

         _treeGenerator = treeGenerator;
         NodeSet initialPopulation = new NodeSet();
         int ctr = 0;
         while (initialPopulation.size() < generationSize) {
            if (ctr++ > generationSize * 10) {
               // throw new RuntimeException(); TODO?
               break;
            }

            Node n = treeGenerator.generate(_returnType, treeDepth);
            initialPopulation.add(n);
         }
         return new InitialPopulationSetter().setInitialPopulation(initialPopulation);
      }

      private int requiresPositive(final int i) { // TODO move to Utils
         if (i > 0) {
            return i;
         } else {
            throw new IllegalArgumentException("Expected a positive integer but got: " + i);
         }
      }
   }

   private PrimitiveSet[] _primitiveSets; // TODO
   private TreeGenerator[] _treeGenerators; // TODO

   /**
    * Provides the option to configure how new generations evolve from existing ones, or to skip that option and instead configure the termination criteria.
    * <p>
    * If you do not explicitly specify how generations evolve then a default strategy will be used. The default strategy is sufficient for allowing people to
    * quickly get started with OakGP
    */
   public final class GenerationEvolverSetter extends FirstTerminatorSetter {
      private GenerationEvolverSetter() {
      }

      /** Set how new generations will be created from existing ones. */
      public TerminatorSetter setGenerationEvolver(final java.util.function.Function<Config, GenerationEvolver> generationEvolver) {
         return setGenerationEvolver(generationEvolver.apply(new Config()));
      }

      /** Set how new generations will be created from existing ones. */
      private TerminatorSetter setGenerationEvolver(GenerationEvolver generationEvolver) {
         _generationEvolver = requireNonNull(generationEvolver);
         return new FirstTerminatorSetter();
      }
   }

   private class FirstTerminatorSetter implements TerminatorSetter {
      private final List<Predicate<RankedCandidates>> terminators = new ArrayList<>();

      private FirstTerminatorSetter() {
      }

      @Override
      public TerminatorSetterOrProcessRunner setTerminator(final Predicate<RankedCandidates> terminator) {
         terminators.add(requireNonNull(terminator));
         return new SubsequentTerminatorSetter(terminators);
      }

      @Override
      public MaxGenerationsTerminatorSetterOrProcessRunner setTargetFitness(double targetFitness) {
         return new SubsequentTerminatorSetter(terminators).setTargetFitness(targetFitness);
      }

      @Override
      public MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner setMaxGenerations(final int maxGenerations) {
         return new MaxGenerationsTerminatorSetterImpl(terminators).setMaxGenerations(maxGenerations);
      }

      @Override
      public ProcessRunner setMaxGenerationsWithoutImprovement(int maxGenerationsWithoutImprovement) {
         return new MaxGenerationsWithoutImprovementTerminatorSetterImpl(terminators).setMaxGenerationsWithoutImprovement(maxGenerationsWithoutImprovement);
      }
   }

   private final class SubsequentTerminatorSetter extends MaxGenerationsTerminatorSetterImpl implements TerminatorSetterOrProcessRunner {
      private SubsequentTerminatorSetter(List<Predicate<RankedCandidates>> terminators) {
         super(terminators);
      }

      @Override
      public TerminatorSetterOrProcessRunner setTerminator(final Predicate<RankedCandidates> terminator) {
         terminators.add(terminator);
         return this;
      }

      @Override
      public MaxGenerationsTerminatorSetterOrProcessRunner setTargetFitness(double targetFitness) {
         terminators.add(new TargetFitnessTerminator(c -> Math.abs(c.getFitness() - targetFitness) < .0000001));
         return new MaxGenerationsTerminatorSetterImpl(terminators);
      }
   }

   private class MaxGenerationsTerminatorSetterImpl extends MaxGenerationsWithoutImprovementTerminatorSetterImpl
         implements MaxGenerationsTerminatorSetterOrProcessRunner {
      private MaxGenerationsTerminatorSetterImpl(List<Predicate<RankedCandidates>> terminators) {
         super(terminators);
      }

      @Override
      public final MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner setMaxGenerations(int maxGenerations) {
         terminators.add(new MaxGenerationsTerminator(maxGenerations));
         return new MaxGenerationsWithoutImprovementTerminatorSetterImpl(terminators);
      }
   }

   private class MaxGenerationsWithoutImprovementTerminatorSetterImpl implements MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner {
      protected final List<Predicate<RankedCandidates>> terminators;

      private MaxGenerationsWithoutImprovementTerminatorSetterImpl(List<Predicate<RankedCandidates>> terminators) {
         this.terminators = terminators;
      }

      @Override
      public final ProcessRunner setMaxGenerationsWithoutImprovement(int maxGenerationsWithoutImprovement) {
         terminators.add(new MaxGenerationsWithoutImprovementTerminator(maxGenerationsWithoutImprovement));
         return new ProcessRunnerImpl(terminators);
      }

      @Override
      public final RankedCandidates process() {
         return new ProcessRunnerImpl(terminators).process();
      }
   }

   private final class ProcessRunnerImpl implements ProcessRunner {
      private Predicate<RankedCandidates> terminator;

      @SuppressWarnings("unchecked")
      private ProcessRunnerImpl(List<Predicate<RankedCandidates>> terminators) {
         if (terminators.isEmpty()) {
            throw new IllegalStateException("No termination criteria set");
         } else if (terminators.size() == 1) {
            terminator = terminators.get(0);
         } else {
            terminator = new CompositeTerminator(terminators.toArray(new Predicate[terminators.size()]));
         }
      }

      @Override
      public RankedCandidates process() {
         // TODO check here, or earlier, that all constants, variables and functions
         // are useable (i.e. their return types and args are types in use by other elements of the primitive set)
         if (_generationEvolver == null) {
            _generationEvolver = createDefaultGenerationEvolver();
         }

         RankedCandidates rankedCandidates = Runner.process(_generationRanker, _generationEvolver, terminator, _initialPopulation);
         RankedCandidate best = rankedCandidates.best();
         Node simplifiedBestNode = simplify(best.getNode());
         Logger.getGlobal().info("Best candidate: Fitness: " + best.getFitness() + " Structure: " + simplifiedBestNode);
         return rankedCandidates;
      }

      private GenerationEvolver createDefaultGenerationEvolver() {
         int populationSize = _initialPopulation.size();
         NodeSelectorFactory nodeSelectorFactory = new RankSelectionFactory(_random);
         Map<GeneticOperator, Integer> operators = createDefaultGeneticOperators(populationSize);
         int operatorsSize = operators.values().stream().mapToInt(Integer::intValue).sum();
         int elitismSize = populationSize - operatorsSize;
         Logger.getGlobal().info("total: " + populationSize + " elitism: " + elitismSize + " " + operators);
         return new GenerationEvolverImpl(elitismSize, nodeSelectorFactory, operators);
      }

      private Map<GeneticOperator, Integer> createDefaultGeneticOperators(int populationSize) { // TODO use adf wrapper if required
         if (_automaticallyDefinedFunctions.size() == 1) {
            Map<GeneticOperator, Integer> operators = new HashMap<>();
            operators.put(t -> _treeGenerator.generate(_returnType, 4), ratio(populationSize, .08)); // .08
            operators.put(new CrossoverWrapper(new SubtreeCrossover(5), _random), ratio(populationSize, .4)); // .4
            operators.put(new MutateWrapper(new PointMutation(), _primitiveSet, _treeGenerator, _random), ratio(populationSize, .4)); // .4
            operators.put(new MutateWrapper(new SubTreeMutation(), _primitiveSet, _treeGenerator, _random), ratio(populationSize, .08)); // .08
            return operators;
         } else {
            Map<GeneticOperator, Integer> operators = new HashMap<>();
            operators.put(t -> _treeGenerator.generate(_returnType, 4), ratio(populationSize, .08)); // .08
            operators.put(new AdfCrossoverWrapper(new SubtreeCrossover(5), _random), ratio(populationSize, .4)); // .4
            operators.put(new AdfMutateWrapper(new PointMutation(), _primitiveSets, _treeGenerators, _random), ratio(populationSize, .4)); // .4
            operators.put(new AdfMutateWrapper(new SubTreeMutation(), _primitiveSets, _treeGenerators, _random), ratio(populationSize, .08)); // .08
            return operators;
         }
      }

      private int ratio(int whole, double ratio) {
         return (int) (whole * ratio);
      }
   }

   /** Allows the function set to be configured. */
   public interface FunctionSetSetter {
      /** Sets the functions that are available for use in the construction of programs generated by the run. */
      SequentialSetter setFunctionSet(FunctionSet functionSet);

      /** Sets the functions that are available for use in the construction of programs generated by the run. */
      default SequentialSetter setFunctions(Function... functions) {
         return setFunctionSet(new FunctionSetBuilder().addAll(functions).build());
      }

      /** Sets the functions that are available for use in the construction of programs generated by the run. */
      default SequentialSetter setFunctions(List<Function> functions) {
         return setFunctionSet(new FunctionSetBuilder().addAll(functions.toArray(new Function[functions.size()])).build());
      }
   }

   /** Provides a method for starting the genetic programming run or setting more termination criteria. */
   public interface TerminatorSetterOrProcessRunner extends TerminatorSetter, ProcessRunner {
   }

   /** Allows termination criteria to be configured. */
   public interface TerminatorSetter extends MaxGenerationsTerminatorSetter {
      /** Sets the criteria used by this run to determine when it should stop. */
      TerminatorSetterOrProcessRunner setTerminator(Predicate<RankedCandidates> terminator);

      /** Set the target fitness that when found should cause the run to stop. */
      MaxGenerationsTerminatorSetterOrProcessRunner setTargetFitness(double targetFitness);
   }

   /** Provides a method for starting the genetic programming run or setting more termination criteria. */
   public interface MaxGenerationsTerminatorSetterOrProcessRunner extends MaxGenerationsTerminatorSetter, ProcessRunner {
   }

   /** Allows termination criteria to be configured. */
   public interface MaxGenerationsTerminatorSetter extends MaxGenerationsWithoutImprovementTerminatorSetter {
      /** Sets the maximum number of generations the run should process before stopping. */
      MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner setMaxGenerations(int maxGenerations);
   }

   /** Provides a method for starting the genetic programming run or setting more termination criteria. */
   public interface MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner extends MaxGenerationsWithoutImprovementTerminatorSetter, ProcessRunner {
   }

   /** Allows termination criteria to be configured. */
   public interface MaxGenerationsWithoutImprovementTerminatorSetter {
      /** Sets the number of consecutive generations without improvement the run should process before stopping. */
      ProcessRunner setMaxGenerationsWithoutImprovement(int maxGenerationsWithoutImprovement);
   }

   /** Provides a method for starting the genetic programming run. */
   public interface ProcessRunner {
      /**
       * Processes a genetic programming run using the values configured earlier for this {@code RunBuilder}.
       *
       * @return the final generation produced as part of this run - the best candidate of this generation can be retrieved using
       *         {@link RankedCandidates#best()}
       */
      RankedCandidates process();
   }

   /** Provides access to configuration values that have already been set on a {@code RunBuilder}. */
   public final class Config {
      public PrimitiveSet getPrimitiveSet() {
         return _primitiveSet;
      }

      public Random getRandom() {
         return _random;
      }

      public Type getReturnType() {
         return _returnType;
      }
   }
}
